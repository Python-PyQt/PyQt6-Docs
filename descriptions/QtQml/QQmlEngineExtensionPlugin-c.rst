.. sip:class-description::
    :status: todo
    :brief: Abstract base for custom QML extension plugins
    :digest: 7cf021bbeaf74c42c4f0c3cf718748ce

The :sip:ref:`~PyQt6.QtQml.QQmlEngineExtensionPlugin` class provides an abstract base for custom QML extension plugins.

:sip:ref:`~PyQt6.QtQml.QQmlEngineExtensionPlugin` is a plugin interface that lets you create QML extensions that can be loaded dynamically into QML applications. These extensions allow custom QML types to be made available to the QML engine.

To write a QML extension plugin:

#. Subclass :sip:ref:`~PyQt6.QtQml.QQmlEngineExtensionPlugin` and use the Q_PLUGIN_METADATA() macro to register the plugin with the Qt meta object system.

#. Use the QML_ELEMENT and QML_NAMED_ELEMENT() macros to declare QML types.

#. Configure your build file.

   CMake:

   ::

       qt_add_qml_module(<target>
           URI <my.import.name>
           VERSION 1.0
           QML_FILES <app.qml>
           NO_RESOURCE_TARGET_PATH
       )

   qmake:

   ::

       CONFIG += qmltypes
       QML_IMPORT_NAME = <my.import.name>
       QML_IMPORT_MAJOR_VERSION = <version>

#. If you're using qmake, create a `qmldir file <https://doc.qt.io/qt-6/qtqml-modules-qmldir.html>`_ to describe the plugin. Note that CMake will, by default, automatically generate the `qmldir file <https://doc.qt.io/qt-6/qtqml-modules-qmldir.html>`_.

QML extension plugins are for either application-specific or library-like plugins. Library plugins should limit themselves to registering types, as any manipulation of the engine's root context may cause conflicts or other issues in the library user's code.

**Note:** When using the CMake `qt_add_qml_module <https://doc.qt.io/qt-6/qt-add-qml-module.html>`_ API, a plugin will be generated automatically for you. It will take care of type registration. You only need to write a custom plugin if you have special requirements, such as registering custom image providers. In that case, pass `NO_GENERATE_PLUGIN_SOURCE <https://doc.qt.io/qt-6/qt-add-qml-module.html#no-generate-plugin-source>`_ to the ``qt_add_qml_module`` call to disable the generation of the default plugin.

The linker might erroneously remove the generated type registration function as an optimization. You can prevent that by declaring a synthetic volatile pointer to the function somewhere in your code. The function is generated by `qmltyperegistrar <https://doc.qt.io/qt-6/qtqml-tooling-qmltyperegistrar.html>`_, and is named ``qml_register_types_`` concatenated with the module URI, with any dots replaced by underscores.

If your module is called "my.module", you would add the forward declaration in global scope:

::

    void qml_register_types_my_module();

Then add the following snippet of code in the implementation of any function that's part of the same binary as the registration:

::

    volatile auto registration = &qml_register_types_my_module;
    Q_UNUSED(registration);

The `Writing QML Extensions with C++ <https://doc.qt.io/qt-6/qtqml-tutorials-extending-qml-example.html>`_ tutorial also contains a chapter on creating QML plugins.

.. seealso:: How to Create Qt Plugins.
